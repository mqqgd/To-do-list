### [240\. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

Difficulty: **中等**


编写一个高效的算法来搜索 `_m_ x _n_` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

*   每行的元素从左到右升序排列。
*   每列的元素从上到下升序排列。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= n, m <= 300`
*   `-10<sup>9</sup> <= matix[i][j] <= 10<sup>9</sup>`
*   每行的所有元素从左到右升序排列
*   每列的所有元素从上到下升序排列
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`


#### Solution

Language: ****

```
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */

//从右上角开始找
var searchMatrix = function(matrix, target) {
//     let m = matrix.length, n = matrix[0].length;
    
//     let i = 0, j = n - 1;
//     while(i < m && j >= 0){
//         if(matrix[i][j] === target){
//             return true;
//         }
//         else if(matrix[i][j] > target){
            
//             j--;
//         }
//         else{
//             i++;
//         }
//     }
//     return false;
// };

//方法2
// 从右上角往左下角看，就是一个二叉搜索树
// 从 右上角开始寻找
    let m = 0, n = matrix[0].length - 1;
    // 一直查找到左下角
    while (m < matrix.length && n >= 0) {
        if (target === matrix[m][n]) return true;
        // 二叉搜索树的性质，左子树小，右子树大
        if (target > matrix[m][n]) m++;
        else n--;
    }
    return false;
};
```