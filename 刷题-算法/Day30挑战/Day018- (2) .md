### [56\. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

Difficulty: **中等**


以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**

*   `1 <= intervals.length <= 10<sup>4</sup>`
*   `intervals[i].length == 2`
*   `0 <= start<sub style="display: inline;">i</sub> <= end<sub style="display: inline;">i</sub> <= 10<sup>4</sup>`


#### Solution

Language: ****

```
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    let res = [];
    intervals.sort((a,b) => a[0] - b[0]);//左端端点先升序排序
    
    let pre = intervals[0];
    for(let i = 1; i < intervals.length; i++){
        let cur = intervals[i];
        if(pre[1] >= cur[0]){   //第一区间的右端点 > 第二个区间的左端点   合并区间
            pre[1] = Math.max(pre[1],cur[1]);    //合并后的区间取两个区间中右端点最大的值作为合并后的区间的右端点
            
        }
        else{
            res.push(pre);
            pre = cur;
        }
        
    }
    res.push(pre);  //将最后合并后的区间push到res中
    return res;

};

// let res = [];
//   intervals.sort((a, b) => a[0] - b[0]);

//   let prev = intervals[0];

//   for (let i = 1; i < intervals.length; i++) {
//     let cur = intervals[i];
//     if (prev[1] >= cur[0]) { // 有重合
//       prev[1] = Math.max(cur[1], prev[1]); 
//     } else {       // 不重合，prev推入res数组 
//       res.push(prev);
//       prev = cur;  // 更新 prev
//     }
//   }

//   res.push(prev);
//   return res;
```

### [119\. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

Difficulty: **简单**


给定一个非负索引 _k_，其中 _k_ ≤ 33，返回杨辉三角的第 _k_ 行。

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

<small style="display: inline;">在杨辉三角中，每个数是它左上方和右上方的数的和。</small>

**示例:**

```
输入: 3
输出: [1,3,3,1]
```

**进阶：**

你可以优化你的算法到 _O_(_k_) 空间复杂度吗？


#### Solution

Language: ****

```
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let resultArr = [1];
        for (let i = 0; i < rowIndex; i++) {
            resultArr.unshift(0);  //每次对上一行补0
            console.log(resultArr)
            for (let j = 0; j < i + 1; j++) {
                resultArr[j] = resultArr[j] + resultArr[j + 1];
                console.log("res",resultArr)
            }
        }
    return resultArr;
    
//     let resultArr = [1];
//  for (let i = 0; i < rowIndex; i++) {
//      resultArr.unshift(0);
//      const midIndex = Math.floor((i + 1) / 2);
//      for (let j = 0; j < i + 1; j++) {
//          if (j > midIndex) {
//              resultArr[j] = resultArr[midIndex + ((i + 1) % 2) - (j - midIndex)];
//              continue;
//          }
//          resultArr[j] = resultArr[j] + resultArr[j + 1];
//      }
//  }
//  return resultArr;

// 作者：clarkchainer
// 链接：https://leetcode-cn.com/problems/pascals-triangle-ii/solution/js-yang-hui-san-jiao-ii-972-shi-suan-he-tu-suan-si/



};
```