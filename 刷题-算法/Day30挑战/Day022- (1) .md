### [435\. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

Difficulty: **中等**


给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1.  可以认为区间的终点总是大于它的起点。
2.  区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```


#### Solution

Language: ****

```
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    if(intervals.length === 0) return 0;
    
    intervals.sort((a,b) => a[1] - b[1]);  
    let end = intervals[0][1];  //记录区间尾部的位置
    let count = 0;  //需要移除的数量
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < end) {
            //如果重叠了，必须要移除一个，所以count要加1，
            //然后更新尾部的位置，我们取尾部比较小的
            end = Math.min(end, intervals[i][1]);
            count++;
        } else {
            //如果没有重叠，就不需要移除，只需要更新尾部的位置即可
            end = intervals[i][1];
        }
    }
    return count;
    
    
};

//首先要对区间进行排序，这里先以区间的头来排序，然后在遍历区间。
// 1，如果后面区间的头小于当前区间的尾，
// 比如当前区间是[3,6]，后面区间是[4,5]或者是[5,9]
// 说明这两个区间有重复，必须要移除一个，那么要移除哪个呢，为了防止在下一个区间和现有区间有重叠，我们应该让现有区间越短越好，所以应该移除尾部比较大的，保留尾部比较小的。
// 2，如果后面区间的头不小于当前区间的尾，说明他们没有重合，不需要移除
// 链接：https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-ji-bai-liao-100de-y-kkzr/




// var eraseOverlapIntervals = function(intervals) {
//     const n = intervals.length
//     if (n === 0) return 0
//     intervals.sort((a, b) => a[1] - b[1])
```