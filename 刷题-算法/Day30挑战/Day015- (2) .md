### [11\. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

Difficulty: **中等**


给你 `n` 个非负整数 `a<sub style="display: inline;">1</sub>，a<sub style="display: inline;">2，</sub>...，a`<sub style="display: inline;">`n`，</sub>每个数代表坐标中的一个点 `(i, a<sub style="display: inline;">i</sub>)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, a<sub style="display: inline;">i</sub>)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**示例 1：**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**示例 3：**

```
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4：**

```
输入：height = [1,2,1]
输出：2
```

**提示：**

*   `n = height.length`
*   `2 <= n <= 3 * 10<sup>4</sup>`
*   `0 <= height[i] <= 3 * 10<sup>4</sup>`


#### Solution

Language: ****

```
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let i = 0, j = height.length - 1;
    let res = 0;
    
    while(i < j){
        let area = (j - i) * Math.min(height[i], height[j]);
        //固定一侧柱子
        //如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。
        if(height[i] < height[j]){//左边柱子短，则固定右边柱子。
            i++;   
        }
        else{
            j--;
        }
        res = Math.max(res, area);
    }
    
    return res;

};
```

### [167\. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

Difficulty: **简单**


给定一个已按照**升序排列 ** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值_。_`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
```

**提示：**

*   `2 <= numbers.length <= 3 * 10<sup>4</sup>`
*   `-1000 <= numbers[i] <= 1000`
*   `numbers` 按 **递增顺序** 排列
*   `-1000 <= target <= 1000`
*   仅存在一个有效答案


#### Solution

Language: ****

```
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    let i = 0, j = numbers.length - 1;
    let res = [];
    
    while(i < j){
        let sum = numbers[i] + numbers[j];
        if(sum === target){
            return res = [i+1,j+1];
        }
        else if(sum < target){
            i++;
        }
        else{
            j--;
        }
    }
    return res;
};
```