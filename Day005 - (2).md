### [3\. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

Difficulty: **中等**


给定一个字符串，请你找出其中不含有重复字符的 **最长子串 **的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```
输入: s = ""
输出: 0
```

**提示：**

*   `0 <= s.length <= 5 * 10<sup>4</sup>`
*   `s` 由英文字母、数字、符号和空格组成


#### Solution

Language: ****

```
/**
 * @param {string} s
 * @return {number}
 */

//滑窗法
var lengthOfLongestSubstring = function(s) {//abcade
    
    let str = '';
    let length = 0;
    
    for(let i = 0; i < s.length; i++){
        if(str.indexOf(s[i]) == -1){
            str += s[i];  //abc
        }else{
            length = Math.max(length, str.length);   //length: 3
            str = str.slice(str.indexOf(s[i]) + 1) + s[i];  //0+1-->b  str:bc + a
        }
    }
    return Math.max(length, str.length);

};
```





### [53\. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

Difficulty: **简单**


给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

**提示：**

*   `1 <= nums.length <= 3 * 10<sup>4</sup>`
*   `-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>`

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。


#### Solution

Language: ****

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
   
    let max = nums[0];
    let curr = nums[0];
     if(nums.length===1) return max;
    // let res = [];
    
    for (let i = 1; i < nums.length; i++){
        curr += nums[i];
        curr = Math.max(curr,nums[i]);
        max = Math.max(max,curr);
        
        // arr.append(nums[i]);
    }
    return max;
};
```