## CSS+HTML

#### HTML5新增了哪些新的属性？

新增语义结构标签

新增表单元素

新增表单属性  form  和  input



#### HTML5语义化标签的理解

提升代码可读性，便于团队开发和维护，当网页去掉CSS样式时，页面能呈现出来清晰的结构

#### 块级元素和行内元素（内联元素）区别 ♥ 

```
1.行内元素:
	和其他行内元素都会在一条水平线上排列，都是在同一行的；
	不能设置width和height；宽高随文本内容的变化而变化，可设置行高，同时在设置外边距margin上下无效，左右有效，内填充padding上下无效，左右有效；
	
块级元素:
	各个块级元素独占一行，垂直向下排列，若想使其水平方向排序，可使用左右浮动（float：left/right）让其水平方向排列。
	可以设置宽高，默认宽度为父级的100%，宽度高度以及外边距，内填充都可随意控制。  
   
2.相互转换：
	通过修改display属性值来切换块级元素和行内元素，display：inline（变为行内元素）， display：block（转为块级元素）。
	float浮动。
	
注意：display:inline-block;行内块 缺点：间隙、基线对齐问题
	float 浮动 行内块   缺点：脱离文档流(父级找不到子级)   优点：没有基线对齐问题、间隙

3.块级元素可以包含行内元素和块级元素，还可以容纳内联元素和其他元素；行内元素不能包含块级元素，只能容纳文本或者其他行内元素。
```

<img src="https://iknow-pic.cdn.bcebos.com/80cb39dbb6fd52669b108d65a618972bd4073683?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img" style="zoom:50%;" />

♥ ♥ ♥  **img元素属于块级元素还是行内元素？**

img标签没有独占一行，是行内元素，属于替换元素，具有内置的宽高属性，所以可以设置宽高

#### 行内元素设置margin

```
只可以设置水平方向（左右）的边距，如：margin-left,margin-right,padding-left,padding-right.
```

#### 水平居中，垂直居中 ♥ ♥ ♥ 

+ 水平居中

  ```
  1、行内元素：看父元素是不是块级元素，是，则直接给父元素设置text-align: center;
  
             不是，则先将父元素设置为块级元素，再给父元素设置text-align: center;
  
  2、块级元素：
  	1）分宽度定不定两种情况： 
  	定宽度：需要谁居中，给其设置margin: 0 auto;（作用：使盒子自己居中）；
  	不定宽度：默认子元素的宽度和父元素一样，这时需要设置子元素为display: inline-block;或 display: inline;即将其转换成行内块级/行内元素，给父元素设置 text-align: center;
  	
  	2）使用定位
  	首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**left:50%**，即让子元素的左上角水平居中；
  	定宽度：设置绝对子元素的margin-left: -元素宽度的一半px; 或者设置transform: translateX(-50%);
  	不定宽度：利用css3新增属性transform: translateX(-50%);
  	
  	3）使用flexbox布局（宽度定不定都可以）
  	使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 display: flex; justify-content: center;
  ```

+ 垂直居中

  ```
  1、单行的行内元素
  	只需要设置单行行内元素的"行高等于盒子的高"即可line-height；
  2、多行的行内元素
  	使用给父元素设置display:table-cell;和vertical-align: middle;属即可；
  3、块级元素
  	1）使用定位
  	首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的top: 50%，即让子元素的左上角垂直居中；
  	定高度：设置绝对子元素的 margin-top: -元素高度的一半px; 或者设置transform: translateY(-50%);
  	不定高度：利用css3新增属性transform: translateY(-50%);
  	
  	2）使用flexbox布局实现（高度定不定都可以）
  	使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 display: flex; align-items: center;
  ```

+ 水平垂直居中

  ```
  1、已知高度和宽度的元素
  	1）设置父元素为相对定位，给子元素设置绝对定位，top: 0; right: 0; bottom: 0; left: 0; margin: auto;
  	2）设置父元素为相对定位，给子元素设置绝对定位，left: 50%; top: 50%; margin-left: -元素宽度的一半px; margin-top: -元素高度的一半px;
  	
  2、未知高度和宽度的元素
  	1）使用定位
  	设置父元素为相对定位，给子元素设置绝对定位，left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);
  	2）使用flex布局
  	设置父元素为flex定位，justify-content: center; align-items: center;
  	
  	
  ```

  

#### 鼠标移动到元素上，改变宽高的方法

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827102902095.png" alt="image-20210827102902095" style="zoom:67%;" />

#### scale 和直接改变宽高哪个方式更好

CSS中transform的scale(x, y)方法动态调整视频宽高大小实现满屏播放

 

#### 说说回流、重绘，哪个更消耗性能及其运用  ♥ ♥ 

```
回流：当渲染树中的一部分（或全部）因为元素的尺寸、布局、隐藏等改变而重新构建。每个页面至少需要一次回流，就是页面在第一次加载的时候

重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的。

注意：回流必将引起重绘，而重绘不一定会引起回流

```

回流更消耗性能，回流的花销跟渲染树有多少节点需要重新构建有关系

#### 如何设置点击盒子时给盒子外加一个边框

outline

div{border-top:1px solid #000} 

1、border这个属性，例子：border:1px solid grey;
2、box-shadow这个属性，例子:box-shadow:0 0 3px grey;



#### 盒子模型，标准盒子和ie盒子的区别 ♥ 

盒模型从内到外依次是啥

- **element**:元素
- **padding**:内边距
- **border**:边框
- **margin**:外边距
  这些元素组合起来构成了一个盒子，所以叫做**css的盒模型**

**两者的区别在于content的不同，IE盒模型的content包括border、padding**

当使用content-box时：页面将采用标准模式来解析计算，content-box也是默认模式

当使用border-box时，页面将采用怪异模式解析计算，怪异模式也称为IE模式

当使用inherit时：页面将从父元素继承box-sizing的值



#### flex布局 ♥   ♥  

#### flex :1是什么？

**flex****属性** 是 flex-grow、flex-shrink、flex-basis三个属性的缩写。

第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
第三个参数表示: flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小

**flex: 1; === flex: 1 1 0;**

均匀分配元素，flex:1 1 auto

在一个div中有三个子div，设置flex：1会达到什么效果呢？ 我当时说的 宽度会平分

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827104338711.png" alt="image-20210827104338711" style="zoom:67%;" />

#### 相对定位和绝对定位

+ 绝对定位：是相对于元素**最近的已定位的祖先元素（**即是设置了绝对定位或者相对定位的祖先元素）。如果元素没有已定位的祖先元素，那么它的位置则是相对于**最初的包含块（body）**。

  绝对定位与文档流无关，所以它们可以覆盖页面上其他的元素，可以通过z-index属性来控制这些层的对方顺序。

+ 相对定位：是相对于元素在文档中的**初始位置**；

  注意，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。

<img src="https://img-blog.csdn.net/20180523095901836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncWw1MTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />

```
注意：position:absolute，float会隐式地改变display的类型（display：none除外）。即是当元素设置position:absolute、float:left、float:right中任意一个时，都会让元素以display:inline-block的方式显示（特点是：可以设置长宽，默认宽度不占满父元素）。这时，即使故意设置display:inline; display:block都是无效的。

但是float在IE6下的双边距bug就是用display:inline; 来解决的。
position:relative不会隐式改变display的类型。
```



#### CSS3动画属性    ♥ 

transition ：  平衡过渡

一般transition通过鼠标事件触发 ，如（hover）产生动画效果

animation： 动画

animation一般通过@keframes关键帧的规则来创建动画，可以通过关键字"from"和“to”,或者通过自己定义的百分比进行动画 0%是开始100%是结束

transform： 改变元素的大小、位置

​	translate：移动

translate（x,y） 定义2D空间

translate（x,y,z） 定义3D空间

这个的移动值可以使用像素px支持负值

scale：放大

scale（数值）定义图片放几倍大（0为不显示,1则是图片原本的大小）

rotate：旋转

rotate(x,y) 定义2D空间

rotate(x,y,z) 定义3D空间

这个的旋转值使用deg 旋转了多少度，支持负值

#### CSS选择器，及优先级  ♥ 

CSS三大特性—— **继承、 优先级和层叠。**

**继承：**即子类元素继承父类的样式;

**优先级：**是指不同类别样式的权重比较;

**层叠：**是说当数量相同时，通过层叠(后者覆盖前者)的样式。

**总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**

#### 怎么画正方形，三角形





#### sass和less  , sass如何转换成css代码？



#### 给元素添加样式有哪些方法？



#### position有哪些值，这些值有哪些区别？ position有哪些属性，跟父级元素是如何相对定位的？根据X和Y坐标吗？

absolute和relative的区别

如果父元素全是static，absolute相对于什么定位

absolute和relative哪个会使元素脱离文档流  ♥ 

还有什么可以让元素脱离文档流   

文档流就是指元素在 HTML 文档中位置顺序决定排布的过程

​     可以使用 float、absolute/fixed 来脱离文档流。脱离文档流的元素不受文档流内元素的影响。

​	使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。

​	因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，

fixed完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。



#### BFC产生的条件，特点





#### css实现一个三角形箭头



#### img标签中title和alt标签的区别，有什么用

```
alt属性是图片因为某种原因不能加载时在页面显示的提示信息，它会直接输出在原本加载图片的地方。
title属性是在你鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了，有点类似jQuery的hover，你可以自己试试，另外，HTML的绝大多数标签都支持title属性，title属性就是专门做提示信息的。
```



#### 如果img的图片获取不到，怎么设置默认图片

好像img标签有一个错误事件可以设置

可以给 img 标签设置一个 onerror 属性，可以在 src 路径不存在时显示指定的默认图片。

#### href 和src的区别

```
 1、href是Hypertext Reference的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。
 	<link href="reset.css" rel=”stylesheet“/>
    浏览器会识别该文档为css文档，并行下载该文档，并且不会停止对当前文档的处理（即不会阻止浏览器的渲染）。这也是建议使用link，而不采用@import加载css的原因。
    
 2、src是source的缩写，src的内容是页面必不可少的一部分，是引入。src指向的内容会嵌入到文档中当前标签所在的位置。常用的有：img、script、iframe。例如：
 	<script src="script.js"></script>
	当浏览器解析到该元素时，会暂停浏览器的渲染，直到该资源加载完毕才继续下面的执行。这也是将js脚本放在底部而不是头部得原因。
	src用于替换当前元素；href用于在当前文档和引用资源之间建立联系。
	
```

#### 除了px外，还有哪些常见的单位

```
rem 相对于根字体大小的单位，比如可以设置html { font-size: 100px;}
em 相对于font-size，以父元素为基准，比如font-size：16px（浏览器默认），则2em=32px
vw 即viewpoint width，视窗宽度，比如1vm的宽度为相对于视窗的宽度的百分之一
vh 即viewpoint height ，同上
vh和vw是相对于视口的高度和宽度，而不是父元素的。%单位是相对于包含它的最近的父元素的宽度和高度。
```

#### 常用布局方式

```
固定布局
流式布局
弹性布局
浮动布局
定位布局
```



## JS

#### let  var  const区别 ，暂时性死区，const定义的可以修改吗？ ♥

先上结论：let，var，const，三者都会变量提升。

- var 是创建和初始化的过程都提升了，所以提前访问得到 undefined。

- let 只是创建过程提升，提前访问报错 xx is not defined，这其实是暂时性死区的表现

- const、class 和 let 相似，只是 const 无法修改变量

- function 的创建、初始化、赋值都提升了，所以提前访问则没啥问题

  let和const都是块级作用域，不存在变量前提
  const是声明常量，不允许改变。但是const定义的是一个对象，keep的仅仅是对象的地址，对象内的属性依旧可以被改变。
  var作用域为函数作用域
  暂时性死区指的是在被let或const定义的变量，在该变量被声明之前无法被访问，会报错

  <img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827112141423.png" alt="image-20210827112141423" style="zoom:67%;" />

  <img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827112228410.png" alt="image-20210827112228410" style="zoom:67%;" />

  <img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827114455545.png" alt="image-20210827114455545" style="zoom:67%;" />

#### 箭头函数，与普通函数的区别  ♥  ♥  ♥   ♥ ♥  

没有arguments，那怎么接受不定参数

```
箭头函数是匿名函数，不能作为构造函数，不能使用new
箭头函数不绑定arguments，取而代之用rest参数...解决
箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
箭头函数没有原型属性
箭头函数不能当做Generator函数,不能使用yield关键字
 
总结：
	箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向，如 call() ,  bind() ,  apply() 
	普通函数的this指向调用它的那个对象
```



#### 说说this，箭头函数的this指向

 <img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827114519552.png" alt="image-20210827114519552" style="zoom:67%;" />

#### Promise(非实例化的promise)的方法 ，原理 ，状态 ♥ ♥ ♥ 

promise共有三个状态：pending（执行中）、success（成功）、rejected（失败）

all    race    resolve    reject  finally 

讲讲all ,  实现思路 ♥  ♥  ♥  ♥ ♥

all里面的promise如果有一个失败了，后面的then还能执行吗？

then不能执行，解决方法：给传入的promise加catch或者promise.al;lsettled

race 的应用：设置网络请求deadline

all与race的作用

如果有两个异步任务，任意一个任务完成了就执行，用什么方法（promise.race()）

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827113440944.png" alt="image-20210827113440944" style="zoom:67%;" />

#### promise的优缺点，api

```
promise的缺点
1、无法取消Promise,一旦新建它就会立即执行，无法中途取消。

2、如果不设置回调函数，promise内部抛出的错误，不会反应到外部。

3、当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

promis的优点
1.解决回调地狱（Callback Hell）问题
（1）有时我们要进行一些相互间有依赖关系的异步操作，比如有多个请求，后一个的请求需要上一次请求的返回结果。过去常规做法只能 callback 层层嵌套，但嵌套层数过多的话就会有 callback hell 问题。比如下面代码，可读性和维护性都很差的。
（2）如果使用 promises 的话，代码就会变得扁平且更可读了。前面提到 then 返回了一个 promise，因此我们可以将 then 的调用不停地串连起来。其中 then 返回的 promise 装载了由调用返回的值。
2，更好地进行错误捕获
多重嵌套 callback 除了会造成上面讲的代码缩进问题，更可怕的是可能会造成无法捕获异常或异常捕获不可控。
（1）比如下面代码我们使用 setTimeout 模拟异步操作，在其中抛出了个异常。但由于异步回调中，回调函数的执行栈与原函数分离开，导致外部无法抓住异常。
（2）如果使用 promises 的话，通过 reject 方法把 Promise 的状态置为 rejected，这样我们在 then 中就能捕捉到，然后执行“失败”情况的回调。
```



#### async await 与promise 的区别   ♥ ♥ 

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827113042611.png" alt="image-20210827113042611" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827113023178.png" alt="image-20210827113023178" style="zoom:67%;" />

#### async   promise   setTimeout执行顺序， 如果await后面还是个async会产生什么问题就执行顺序来说？



#### setTimeout后面的时间为0表示什么？那如果setTimeout后面的时间设为6秒那它一定会是6秒之后执行吗？不一定，要考虑宏任务里面的耗时操作









#### 数组遍历方法，实现方法的不同点在哪儿？♥ ♥ ♥

https://blog.csdn.net/function__/article/details/79555301

#### 数组有哪些方法（es6中又有哪些）♥ 

https://www.cnblogs.com/zyfeng/p/10541133.html



#### filter、map和forEach区别   ♥ ♥  ♥

forEach 返回什么

forEach没有返回值，不能break、continue

forEach：没有返回值，只是对每个元素进行操作

map和filter都有。

map返回一个新的数组，将元素进行处理后返回到新数组。

filter适合得筛选后才能返回出去的数组

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827113835035.png" alt="image-20210827113835035" style="zoom: 80%;" />

#### forEach和for循环的区别 

forEach和for循环都去使用return会达到什么效果

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827113924747.png" alt="image-20210827113924747" style="zoom: 80%;" />



#### 说说 for  in   与 for  of的区别 ♥  ♥



#### 遍历对象属性的方法





#### 如何实现map

Array.prototype.map =  function() = > {}



#### JS的数据类型（基本+引用），二者的区别 ，判断数据类型的方法 ♥ ♥ ♥ ♥ ♥ 

Undefined、Null、Boolean、Number、String、新增:Symbol

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827114305407.png" alt="image-20210827114305407" style="zoom:80%;" />



#### 如何判断数组，instanceof原理？

原型链，用原型链会有一个问题，有个object，我把它的原型链指向数组，那怎么判断呢

```
1、instanceof方法
instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性
2、constructor方法
constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数
3、最简单的方法，这种写法兼容性最好使用Object.prototype.toString.call()
4、ES5新增方法isArray()
```



#### js数组与字符串的api，字符串和数组互转   ♥  



#### 给字符串，怎么找到想要对应字符的位置，有哪些方法？





#### new一个对象的过程，new是怎么实现的   ♥ ♥

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827114329233.png" alt="image-20210827114329233" style="zoom:67%;" />

#### 继承有哪些？如何继承 ♥ ♥



#### 原型和原型链， prototype 与—proto-的区别  ♥  ♥ ♥





#### 函数里面有个name属性，调用一下，在windows下输入windows.this.name输出是什么



#### setTimeout是不是立即执行？



#### setTimeout 和setInterval 的区别



#### 介绍css动画和js动画



#### 手写防抖和节流，应用场景   ♥ ♥  ♥ ♥  ♥

防抖：一定时间内只执行一次，如果再次出发则重新计算时间，即执行的都是最后一次触发的函数；节流：虽然也是一定时间只执行一次但它执行的是第一次触发的函数；



#### 防抖里面用到了一个重要的思想，是什么？

当前环境中存在指向父级作用域的引用

#### 如何实现百度搜索框（输入联想功能）



#### ES6了解哪些，新特性，与es5的区别  ♥  ♥   ♥



#### es6数组扩展





#### Map/Set   ♥



#### 数组去重  ♥ ♥   ♥

https://www.cnblogs.com/fs0196/p/12631928.html   重点



#### 浏览器的事件循环机制，微任务，宏任务 ♥



#### 异步编程的方法有哪些



 #### bind的使用方法和注意事项



#### 深拷贝，浅拷贝





#### 作用域



#### 闭包，闭包的缺点 ♥ ♥  ♥ ♥

如何让外界不能随意调用该函数里的成员和属性

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210827114102603.png" alt="image-20210827114102603" style="zoom:80%;" />

https://segmentfault.com/a/1190000020627528?utm_source=tag-newest

#### sort函数传参



#### 模拟实现数组的push()，至少三种方法  ♥



#### 一个网页文件有很多个js要加载，加载过程会比较慢，如何保证用户想要触发某个功能相应的js已经加载完成？



#### input事件有哪些



#### 如何遍历一个对象？



#### 内存泄漏



#### 事件冒泡，事件委托，事件捕获，默认是捕获还是冒泡   ♥ 

事件委托的时候如何知道是哪个子元素      e.target    e.currentTarget  ???

target 是触发事件的对象,点击的对象.  而currentTarget是触发绑定的对象,也就是向上冒泡触发的对象



#### dom树遍历



#### 事件绑定 addEventListener方法有几个参数，最右一个参数表示什么？



#### js精度处理问题



#### js垃圾回收机制

#### 对象合并





##  网络

#### 状态码有哪些？作用是什么？♥  ♥ 

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831100133483.png" alt="image-20210831100133483" style="zoom: 67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831100343841.png" alt="image-20210831100343841" style="zoom: 67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831100432074.png" alt="image-20210831100432074" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831100536355.png" alt="image-20210831100536355" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831100616583.png" alt="image-20210831100616583" style="zoom:67%;" />

#### 403 404，出现404是什么问题？是服务器的问题吗？

```
403是服务器禁止访问，404是服务器没找到文件或目录。

导致4错误的原因
1、Web服务扩展锁定策略阻止本请求。
2、无法在所请求的端口上访问Web站点。
3、MIME映射策略阻止本请求。
4、跟踪访问的各类脚码或CSS文件无效但调用代码依然存在。
5、某个目录直接删除（导致一段时间该目录的文件在被爬行时全部报404 Not Found错误）
6、网站更新改版，但某些局部板块沿用原来的模块，而原有的模块调用的文件已经被删除或转移了路径。
7、网页URL生成规则改变、网页文件更名或移动位置、导入链接拼写错误等，导致原来的URL地址无法访问
```



#### 请求头里边都有什么？



#### 浏览器输入完整的url发生什么？





#### 说说浏览器缓存（HTTP缓存）

浏览器存储（如果要存储一个对象，如何存储）

```
浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对静态资源进行存储，当再次请求该页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。而浏览器缓存，本质上就是HTTP的缓存。
```



#### http常见字段有哪些？

```
Host字段
Content-Length字段
Connection字段
Content-Type字段
Content-Enckoding字段
```

#### Content-Type值有哪些 

```
Content-type是Http的实体首部字段，在request的请求行（或response的状态码）之后，也是首部的一部分。用于说明请求或返回的消息主体是用何种方式编码，在request header和response header里都存在。

四种常见取值：
1、application/x-www-form-urlencoded
	最常见 POST 提交数据的方式。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。
	1）浏览器的原生form表单
	2） 提交的数据按照 key1=val1&key2=val2 的方式进行编码，key和val都进行了URL转码
	
2、multipart/form-data
	常见的 POST 数据提交的方式。我们在使用表单上传文件时，必须让 form 的 enctyped 等于这个值。
	
上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 Web/App，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。

3、application/json 
	作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。
 	JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。
 	
4、text/xml 
 	XML-RPC（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。
 	eg: Content-Type: text/html; charset=utf-8
 	表示发送的是网页，编码是utf-8
```

#### GET和POST的区别，应用

```
GET方法：请求从服务器获取资源
POST方法：向URI指定的资源提交数据，数据就放在报文的body里

安全：在HTTP协议里，安全是指请求方法不会破坏服务器上的资源
幂等：多次执行相同的操作，结果都是相同的

GET方法是安全且幂等的，因为它是【只读】操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
POST是【新增/提交数据】的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据会创建多个资源，所以不是幂等的。
```

#### cookieds有哪些字段

```
1、name字段：名称
2、value字段：cookie的值
3、domain字段：为可以访问此cookie的域名，顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。
4、path字段：为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。
5、Size字段：设置cookie的大小
6、http字段：cookie的httponly属性。若为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie
7、expires/Max-Age字段：设置cookie的过期时间。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
8、secure字段：设置是否只能通过https来传递此条cookie
```

#### www.xx.baidu.com（子域名）和www.baidu.com访问这两个能实现cookies共享吗？怎么实现的？



#### 说说HttpOnly





#### 说说Samesite

```
SameSite是Cookie中的一个属性用来限制第三方Cookie，从而减少安全风险。Chrome 51 开始，浏览器的Cookie新增加了一个SameSite属性，用来防止CSRF攻击和用户追踪。

它可以设置三个值：Strict   Lax   None
```

#### Web前端安全

```
从影响面看排名前两位的就是 XSS 和 CSRF，其基本原理都是攻破了浏览器同源策略的限制。

CSRF 漏洞目前的措施一般是验证 referer 或者是用安全 token。而 google 则希望从标准层面去根治这个排名第二的前端安全漏洞。其方案就是给 Cookie 新增一个属性，用这个属性来控制什么情况下可以发送 Cookie，这个属性就是我们今天要讨论的 SameSite 属性。
```

#### CSRF攻击

```
Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击
```



#### get请求的缓存



#### http1.0 ，http1.1 和http2.0的区别  ♥ ♥ 

```
http1.0  
【短连接】，每发起一次请求，都要新建一次TCP三次握手，且是串行请求，做了无谓的TCP连接建立和端口，增加了通信开销

http1.1
（1）提出了【长连接】的通信方式（持久连接） --减轻了服务器端的负载
	减少了TCP连接的重复建立和端口造成的额外开销，减轻了服务器端的负载
	特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态
（2）支持【管道网络传输】   -- 减少整体的响应时间
	即在同一个TCP连接里，客户端可发起多个请求，只要一个请求发出去了，不用等其回来，直可发送第二个请求出去。但是服务器还是按照顺序回应请求，容易发生队头堵塞
（3）队头堵塞
	顺序发送的请求序列中的一个请求因为某种原因被堵塞，后面排队的所有请求也一同被堵塞了，会导致客户端一直请求不到数据。

http2.0
http/2协议是基于HTTPS的，所以安全性也是有保障的
（1）头部压缩
	http/2会【压缩头】，如果同时发出多个请求，他们的头是一样或者相似的，那么协议会【消除重复的部分】
（2）二进制格式     --增加了数据传输的效率
	http/1.1采用的是【纯文本】形式的明文报文，HTTP/2采用【二进制格式】，头信息和数据体都是二进制，并且统称为帧：头信息帧和数据帧
（3）数据流
	数据包不是按顺序发送的，每个请求或回应的所有数据包，称为一个数据流。每个数据流都标记着一个独一无二的编号，规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。
	客户端还可以指定数据流的优先级。
（4）多路复用
	http/2可以在【一个连接中并发多个请求或回应，不用按照顺序一一对应】
	移除了http/1.1中的串行请求，不需要排队等待，也不会再出现队头堵塞问题，【降低了延迟，大幅度提高了连接的利用率】
（5）服务器推送  --减少延时的等待
	服务器不再是被动地响应，也可以主动向客户端发送消息
	

```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901144236659.png" alt="image-20210901144236659" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901145518755.png" alt="image-20210901145518755" style="zoom:80%;" />

```
UDP不会出现http/1.1的队头堵塞和HTTP/2的一个丢包全部重传问题

基于UDP的QUIC协议可实现可靠性传输，QUIC是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用协议，是新协议

```

#### http和https的区别 , https的加密方式？ https服务器为什么把公钥发送给客户端？ ♥ ♥ 

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831110100466.png" alt="image-20210831110100466" style="zoom:67%;" />

```
建立连接的时候：http2比http多了TLS的握手过程，目的是为了通过非对称加密握手协商或交换出对称加密密钥，这个过程最长可以花费2RTT
传输内容的时候：https会把数据进行加密，通常是对称加密数据

SSL/TLS 是同一个东西的不同阶段，传输层安全协议
```

#### https解决了http的哪些问题？

**`http是明文传输，所以安全上存在三种风险：窃听风险、篡改风险、冒充风险`**

```
HTTPS在HTTP与TCP层之间加入了SSL/TLS协议，解决了上述风险：信息加密、校验机制、身份证书
	
HTTPS如何解决上面的三个风险：
	【混合加密】的方式实现信息的机密性，解决了窃听的风险
	【摘要算法】的方式实现完整性，可以校验数据的完整性
	将服务器公钥放入到【数字证书】中，解决了冒充的风险
	
（1）混合加密
	HTTPS采用对称加密和非对称加密结合的【混合加密】方式
```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831113117485.png" alt="image-20210831113117485" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831113341545.png" alt="image-20210831113341545" style="zoom:67%;" />

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密

#### 浏览器是如何保证CA证书是可靠的？

```
CA(数字证书认证机构)

将服务器公钥放在数字证书中，只要证书是可信的，公钥就是可信的
```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210831113747240.png" alt="image-20210831113747240" style="zoom: 50%;" />

#### ajax请求过程，步骤，手写  ♥ 



#### ajax是如何实现的？



#### cookie、localstorage和sessionstorage的区别  ♥ 



#### XMLHttpRequest对象有哪些属性？



#### 浏览器的缓存方式有哪些？区别，应用场景，登录信息存在哪里？浏览器的历史记录

```

```

#### 在哪儿？为什么？



#### webstorage，及如何使其与服务端交互



#### 前端安全和防范

#### TCP   UDP区别 ♥ 

```
TCP是面向连接的、可靠的、基于字节流的传输层通信协议
UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，头部只有8个字节（64位）
```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901153324854.png" alt="image-20210901153324854" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901153425945.png" alt="image-20210901153425945" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901153532020.png" alt="image-20210901153532020" style="zoom:80%;" />

#### 三次握手，为什么不是两次？四次挥手，为什么不五次或者三次？

```
TCP是面向连接的协议，所以使用TCP之前必须先建立连接（通过三次握手）
```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901153745584.png" alt="image-20210901153745584" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901160136793.png" alt="image-20210901160136793" style="zoom: 80%;" />

【**第三次握手时可以携带数据的，前两次握手是不可以携带数据的**】

```
三次握手的原因：
	阻止重复历史连接的初始化/阻止历史连接的建立（主要原因）
	可以同步双方的初始化序列号
	可以避免资源浪费
序列号能保证数据包不重复、不丢弃和按序传输

不使用两次握手和四次握手的原因“
	两次握手：无法阻止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号
	四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数
	
```

```
TCP断开连接时通过【四次挥手】的方式
为什么需要四次：
	关闭连接时，客户端向服务器发送FIN时，仅仅表示客户端不再发送数据了但是还能接收数据
	服务器收到客户端的FIN报文时，先回一个ACK应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送FIN报文给客户端来表示同意现在关闭连接。
	从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的ACK和FIN一般都会分开发送，比三次握手多了一次

```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901155157231.png" alt="image-20210901155157231" style="zoom: 67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210901155222165.png" alt="image-20210901155222165" style="zoom: 80%;" />

注意：主动关闭连接的，采用TIME_WAIT状态

MSL是报文最大生存时间，超过这个时间报文就会被丢弃



#### TCP如何进行流量控制的？如何进行拥塞控制的？使用哪几种机制？ ♥ 

```
TCP有：重传机制、滑动窗口、流量控制、拥塞控制
```

```
流量控制：让发送方根据接收方的实际接受能力控制发送的数据量

让发送发送速率不要过快，让接收方来得及接收。利用【滑动窗口机制】可以很方便的在TCP连接上实现对数据传输端的流量控制。原理：运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。
```

```
拥塞控制：为了避免发送方的数据填满整个网络
拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。

1.TCP发送方首先发送一个数据报，然后等待对方的回应
2.得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报
3.直到出现超时错误，这样，发送端就了解到了通信双方的线路承载能力，也就确定了拥塞窗口的大小

拥塞控制主要是四个算法：
	慢启动：当发送方每没收一个ACK，拥塞窗口cwnd的大小就会加1
	拥塞避免：每收到一个ACK时，cwnd增加1/cwnd
	拥塞发生
	快速恢复
```

```
区别：
1 相同点
现象都是丢包；实现机制都是让发送方发的慢一点、发的少一点。

2 不同点
2.1丢包位置不同
流量控制丢包位置是在接收端上；拥塞控制丢包位置是在路由器上。

2.2作用的对象不同
流量控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理；拥塞控制的对象是网络，怕发送方发的太快，造成网络拥塞，使得网络来不及处理。

3 联系
拥塞控制通常表示的是一个全局性的过程，它会涉及到网络中所有的主机、所有的路由器和降低网络传输性能的所有因素；流量控制发生在发送端和接收端之间，只是点到点之间的控制。

```



#### 当键入网址到网页显示，发生了什么？

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902171321597.png" alt="image-20210902171321597" style="zoom:80%;" />

```
1、HTTP
	浏览器【对URL进行解析】，从而生成发送给Web服务器的请求消息。（URL实际上是请求服务器里的文件资源），对URL进行解析后，浏览器确定了Web服务器和文件名，根据这些信息来【生成HTTP请求消息】了
	
2、DNS  -- 真实地址查询
	进行【域名解析】，查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址(就像打电话必须要知道对方的号码，但是号码难记，就通常保存姓名到通讯录里)
	（域名的层级关系：根DNS服务器、顶级域DNS服务器com、权威DNS服务器server.ccom）

3、协议栈
	通过DNS获取到IP后，就可以把HTTP的传输工作交给操作系统中的【协议栈】
	协议栈的上半部分有两块，分别时负责收发数据的TCP和UDP协议，他们俩会接受应用层的委托执行收发数据的操作，下一部分是用IP协议控制网络包收发操作。
	(1) TCP协议，传输数据之前，TCPx建立连接（三次握手）---下图
	如果HTTP请求消息比较长，超过了MSS的长度，此时TCP就需要把HTTP的数据拆解称一块块的数据发送，而不是一次性发送所有数据。
	双方建立连接后，TCP报文中的数据部分就是存放HTTP头部+数据，组装成TCP报文之后，交给下面的网络层处理；
	(2) IP ----远程定位
	TCP模块在执行连接，收发，断开等各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象
	(3) MAC ---两点传输
	生成IP头部后，接下来网络包还需在IP头部的前面加上MAC头部
	MAC头部是以太网使用的头部，它包含了【接收方和发送方的MAC地址】等信息。一般在TCP/IP通信里，MAC包头的协议类型只使用：0800（IP协议）、0806（ARP协议）--以【广播获取】的形式可以找到路由器的MAC地址

4、网卡  ---出口
	需要【将数字信息转换为电信息】，才能在网线上传输，这才是真正的数据发送过程。
	控制网卡需要靠网卡驱动程序，网卡驱动从IP模块获取到包之后，会将其复制到网卡内的缓存区中，然后会在其开头加上报头和起始帧分界符在末尾加上用于检测错误的帧校验序列。
	
5、交换机  ---送别者
	将网络包原样转发到目的地，交换机工作在MAC层（二层网络设备）
	
	
	
	
	
	
	

```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902160531642.png" alt="image-20210902160531642" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902161420345.png" alt="image-20210902161420345" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902161915760.png" alt="image-20210902161915760" style="zoom:67%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902165550801.png" alt="image-20210902165550801" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902165614238.png" alt="image-20210902165614238" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902165732792.png" alt="image-20210902165732792" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902170011027.png" alt="image-20210902170011027" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210902170331443.png" alt="image-20210902170331443" style="zoom:80%;" />

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210903093931169.png" alt="image-20210903093931169" style="zoom:80%;" />

```
当客户端有多个网卡时，就会有多个IP地址，那么IP头部的源地址应该根据路由表规则，将目标地址与路由表每个条目的子网掩码做&操作，和哪个Destination匹配，就选择对应的网卡作为IP包头得源地址。
```

<img src="C:\Users\malan\AppData\Roaming\Typora\typora-user-images\image-20210903094837686.png" alt="image-20210903094837686" style="zoom:80%;" />

#### 跨域，跨域的方法有哪些？具体机制是什么，如何解决跨域？♥

jsonp   post   cors  nginx

#### JSONP的原理

#### 除了script还有哪些标签不受跨域影响?

img    link



#### TCP/IP的五层协议模型     OS的七层协议模型     TCP协议在哪一层？ftp呢？端口号







## VUE

#### 说说对Vue的了解

#### VUE的生命周期？项目用到了什么生命周期？vue数据请求在哪个生命周期？为什么？♥ ♥ 

#### computed和watch的区别



#### 说一下对MVVM的理解

#### vue双向数据绑定原理  ♥ ♥ ♥ ♥  ♥ ♥ 

#### vue2 和vue3有哪些更新？♥

Object.defineProperty 只是对对象的属性进行劫持、 无法监听新增属性和删除属性、   深层对象的劫持需要一次性递归、 劫持数组时需要重写覆盖部分 Array.prototype 原生方法，Proxy： 真正的对对象本身进行劫持、 可以监听到对象新增删除属性、 只在 getter 时才对对象的下一层进行劫持(优化了性能)、 能正确监听原生数组方法

#### v-if 和 v-show 区别及应用场景，在页面第一次渲染时，哪个比较快  ♥ ♥  ♥  ♥ 

#### vue中@和：是什么的缩写

@是v-on    : 是v-bind

#### v-for中key值的作用  ♥

#### vue状态提升

#### vue与react区别  ♥  ♥ 

#### 子组件间传值

#### vue组件间传值的方法，兄弟组件如何实现传值？eventBus



#### 虚拟DOM，数据的更新，最后是如何反映到真实dom树上的 ♥

#### vuex原理， 为什么要使用vuex?   怎么用的♥ ♥  ♥  

#### 介绍一下vue-router路由传参

#### vue的路由懒加载是怎么实现的？

#### 前端路由是怎么实现的？有哪些方式？ ♥  

#### vue过滤器用过吗？

#### keepalive

#### 说一下vue的常用指令

#### diff算法

#### 虚拟DOM

#### vue框架的优点

#### vue如何实现轮播图插件？

#### proxy

#### js异步处理，哪几种

回调函数

事件监听

发布/订阅

promise对象

async/await



## 移动端

#### 移动端适配问题   ♥  

#### 响应式布局中的rem  em 的区别，哪个是根据根元素变化的

#### 移动端像素和台式机不一样怎么办？

用视口，使比例为1：1

#### 遇到过响应式布局中1px的border问题吗？ 查查论坛



## 项目

#### 说说印象最深刻的一个项目

#### 做过团队协作的项目吗

#### 希望以后做前端哪一块？

#### 对前端的认识，为什么选择前端，如何看待前端这个岗位？

#### 如何部署项目，实现项目？

#### 对项目中的各个模块如何看待，为何要分这么多模块

#### 项目中遇到的难点，如何解决？♥  ♥

#### 职业规划，前端的发展

#### 怎么学习的前端，路线，规划

#### 项目中的收获



## 未知归类

#### 性能优化考虑到了什么？

#### 如何实现图片懒加载？

#### 第一打开显示会监听页面区域吗？

#### 前端性能优化

#### webpack，如何配置  ♥  

#### url到网页展示的过程  ♥

#### 前端打包工具是什么？vue项目用的是什么打包工具？为什么要使用打包工具？

#### 设计模式  ♥ ♥ ，单例模式

#### 路由模式，hash如何实现回退等功能，history模式

#### 了解前后端分离吗，说说认识，有什么优点



#### mysql数据库的隔离级别？mysql的隔离级别是如何实现的？？mysql里边有哪几种索引？答的是组合索引、唯一索引、聚集索引、非聚集索引？索引失效的情况？where子句里如果只对A进行大小判断（非like），并且索引只有A,一定会走索引么？



#### 数据库  having

#### 数据库  索引





## 算法

#### 排序算法，时间复杂度，空间复杂度

#### 实现回文字符串的判断；

#### 链表和数组中查询下标为i的元素的时间复杂度

链表  ：  O（n）   数组  ：O （1）

#### 归并排序

#### 快排，时间复杂度

#### 数组和链表的区别







#### 

## git

#### git 命令





## 场景题

####  如何实现一个输入框，能及时判断用户输入的数据的合法性，用什么实现？

#### 怎么在一个app中嵌入一个h5页面

#### 一个九宫格切换的时候，引起抖动怎么解决

#### 给一个列表每一行加一个删除按钮，有什么办法 

 回答：利用事件委托，给每一个标签添加方法，通过循环用js操作dom添加事件 

  循环方法，最后只能绑定给最后一个，怎么解决 回答了利用闭包，立即执行函数 

  问还有没有别的办法，答在循环是可以用let声明（小哥哥说就是想让说let） 

#### 两行代码实现数组各元素+1；

#### 



## 题外话

#### 如何看待加班，压力？

#### 自己的缺点与不足？

#### 找工作的时候看重公司什么？

#### 和[产品经理]()怎么配合，怎么看待[产品经理]()





  \2. 是否阅读过vue[源码]()，是否深入了解过vue，自己写过组件吗？ 

  \3. pc端，移动端，多个请求去请求一个api，但是对于不同的端，需要的数据格式不同，你怎么区分？ 

  \4. 对于es6的新语法，为了使浏览器支持，除了bable解析，其他的，比如promise解析玩可能还是语法糖，但是浏览器不识别pormise，怎么处理？ 

  \5. 1w行js代码，模块化如何处理? 

  \6. nginx你使用过哪些功能，具体的实现了解过吗? 

  \9. 缓存的实现？304服务端和[前端]()如何是实现？ 

  \10. localStorage，如果满了，[客户端]()如何处理？ 







